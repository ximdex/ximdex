// Generated by CoffeeScript 1.8.0

/**
\details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]

Ximdex a Semantic Content Management System (CMS)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

See the Affero GNU General Public License for more details.
You should have received a copy of the Affero GNU General Public License
version 3 along with Ximdex (see LICENSE file).

If not, visit http://gnu.org/licenses/agpl-3.0.html.

@author Ximdex DevTeam <dev@ximdex.com>
@version $Revision$
 */
angular.module("ximdex.main.controller").controller("XTreeCtrl", [
  "$scope", "$attrs", "xBackend", "xTranslate", "$window", "$http", "xUrlHelper", "xMenu", "$document", "$timeout", function($scope, $attrs, xBackend, xTranslate, $window, $http, xUrlHelper, xMenu, $document, $timeout) {
    var dragStartPosition, expanded, listenHidePanel, loadAction, size;
    $scope.nodeActions = [];
    $scope.selectedNodes = [];
    $scope.selectedTab = 1;
    dragStartPosition = 0;
    expanded = true;
    size = 0;
    listenHidePanel = true;
    loadAction = function(action, nodes) {
      console.log("LOADING", action);

      /*openAction(
          label: action.name,
          name:  action.name,
          command: action.command,
          params: 'method='+action.command+'&nodeid='+node.nodeid,
          nodes: node.nodeid,
          url: X.restUrl + '?action='+action.command+'&nodes[]='+node.nodeid+'&nodeid='+node.nodeid,
          bulk: action.bulk
      ,
          node.nodeid
      )
      $('#bw1').browserwindow(
          'openAction'
      ,
          label: action.name,
          name:  action.name,
          command: action.command,
          params: 'method='+action.command+'&nodeid='+node.nodeid,
          nodes: node.nodeid,
          url: X.restUrl + '?action='+action.command+'&nodes[]='+node.nodeid+'&nodeid='+node.nodeid,
          bulk: action.bulk
      ,
          node.nodeid
      )
       */
    };
    $scope.twoLevelLoad = true;
    $http.get(xUrlHelper.getAction({
      action: "browser3",
      method: "nodetypes"
    })).success(function(data) {
      var i;
      if (data && data.nodetypes) {
        $scope.nodetypes = data.nodetypes;
        $scope.nodetypes = {};
        i = data.nodetypes.length - 1;
        while (i >= 0) {
          $scope.nodetypes[data.nodetypes[i].idnodetype] = data.nodetypes[i];
          i--;
        }
      }
    });
    $http.get(xUrlHelper.getAction({
      action: "browser3",
      method: "read",
      id: "10000"
    })).success(function(data) {
      if (data) {
        $scope.projects = data;
      }
    });
    $http.get(xUrlHelper.getAction({
      action: "browser3",
      method: "read",
      id: "2"
    })).success(function(data) {
      if (data) {
        $scope.ccenter = data;
      }
    });
    $http.get(xUrlHelper.getAction({
      action: "moduleslist",
      method: "readModules"
    })).success(function(data) {
      if (data) {
        $scope.modules = data;
      }
    });
    $scope.toggleNode = function(node) {
      node.showNodes = !node.showNodes;
      if (node.showNodes && !node.collection) {
        $scope.loadChilds(node);
      }
    };
    $scope.loadChilds = function(node) {
      $scope.loadNodeChilds(node, function(nodes) {
        if ($scope.twoLevelLoad) {
          $scope.loadNodesChilds(nodes);
        }
      });
    };
    $scope.loadNodeChilds = function(node, callback) {
      var fromTo, idToSend, maxItemsPerGroup;
      if (node.children && !node.loading) {
        maxItemsPerGroup = parseInt($window.com.ximdex.preferences.MaxItemsPerGroup);
        fromTo = "";
        idToSend = node.nodeid;
        if (node.nodeid === "0" && (node.startIndex != null) && (node.endIndex != null)) {
          fromTo = "&from=" + node.startIndex + "&to=" + node.endIndex;
          idToSend = node.parentid;
        }
        node.loading = true;
        $http.get(xUrlHelper.getAction({
          action: "browser3",
          method: "read",
          id: idToSend
        }) + ("&items=" + maxItemsPerGroup) + fromTo).success(function(data) {
          node.loading = false;
          if (data) {
            node.collection = data.collection;
            if (callback) {
              callback(node.collection);
            }
          }
        }).error(function(data) {
          node.loading = false;
        });
      }
    };
    $scope.loadNodesChilds = function(nodes) {
      var i;
      if (nodes.length < 10) {
        i = nodes.length - 1;
        while (i >= 0) {
          $scope.loadNodeChilds(nodes[i]);
          i--;
        }
      }
    };
    $scope.loadActions = function(node, event) {
      var data, n, nodeToSearch, _i, _len, _ref;
      $scope.select(node, event);
      if (event.type === "press") {
        event.srcEvent.stopPropagation();
      } else {
        event.stopPropagation();
      }
      if (($scope.selectedNodes[0].nodeid == null) | ($scope.selectedNodes[0].nodetypeid == null) | $scope.selectedNodes[0].nodeid === "0") {
        return;
      }
      nodeToSearch = $scope.selectedNodes[0].nodeid;
      if ($scope.selectedNodes.length > 1) {
        _ref = $scope.selectedNodes.slice(1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if ($scope.selectedNodes[0].nodetypeid !== n.nodetypeid) {
            return;
          } else {
            nodeToSearch += "-";
          }
        }
      }
      if ($scope.nodeActions[nodeToSearch] == null) {
        $http.get(xUrlHelper.getAction({
          action: "browser3",
          method: "cmenu",
          nodes: $scope.selectedNodes
        })).success(function(data) {
          if (data) {
            $scope.nodeActions[nodeToSearch] = data;
            if (event.type === "press") {
              data.left = event.center.x;
              data.top = event.center.y;
              data.expanded = "true";
            } else {
              data.left = event.clientX;
              data.top = event.clientY;
              if (event.button === 2) {
                data.expanded = "true";
              } else {
                data.expanded = "false";
              }
            }
            xMenu.open(data, $scope.selectedNodes, loadAction);
          }
        });
      } else {
        data = $scope.nodeActions[nodeToSearch];
        if (event.type === "press") {
          data.left = event.center.x;
          data.top = event.center.y;
          data.expanded = "true";
        } else {
          data.left = event.clientX;
          data.top = event.clientY;
          if (event.button === 2) {
            data.expanded = "true";
          } else {
            data.expanded = "false";
          }
        }
        xMenu.open(data, $scope.selectedNodes, loadAction);
      }
    };
    $window.com.ximdex.emptyActionsCache = function() {
      $scope.nodeActions = [];
    };
    $scope.select = function(node, event) {
      var k, n, pushed, _ref, _ref1;
      if (event.type === "contextmenu") {
        event.stopPropagation();
      } else {
        event.srcEvent.stopPropagation();
      }
      if (event.ctrlKey) {
        _ref = $scope.selectedNodes;
        for (k in _ref) {
          n = _ref[k];
          if (((n.nodeFrom == null) && (node.nodeFrom == null) && (n.nodeTo == null) && (node.nodeTo == null) && n.nodeid === node.nodeid) | ((n.nodeFrom != null) && (node.nodeFrom != null) && (n.nodeTo != null) && (node.nodeTo != null) && n.nodeFrom === node.nodeFrom && n.nodeTo === node.nodeTo)) {
            if (event.button === 0) {
              $scope.selectedNodes.splice(k, 1);
            }
            return;
          }
        }
        pushed = false;
        _ref1 = $scope.selectedNodes;
        for (k in _ref1) {
          n = _ref1[k];
          if (n.nodeid > node.nodeid) {
            $scope.selectedNodes.splice(k, 0, node);
            pushed = true;
            break;
          }
        }
        if (!pushed) {
          $scope.selectedNodes.splice($scope.selectedNodes.length, 0, node);
        }
      } else {
        $scope.selectedNodes = [node];
      }
    };
    $scope.reloadNode = function() {
      if ($scope.selectedNodes.length === 1) {
        $scope.selectedNodes[0].showNodes = true;
        $scope.selectedNodes[0].collection = [];
        return $scope.loadChilds($scope.selectedNodes[0]);
      }
    };
    $scope.doFilter = function() {
      var url;
      if ($scope.filter === "") {
        $http.get(xUrlHelper.getAction({
          action: "browser3",
          method: "read",
          id: "10000"
        })).success(function(data) {
          if (data) {
            $scope.projects = data;
          }
        });
      } else if ($scope.filter.length > 2) {
        url = xUrlHelper.getAction({
          action: "browser3",
          method: "readFiltered",
          id: "10000"
        }) + "&query=" + $scope.filter;
        $http.get(url).success(function(data) {
          if (data) {
            $scope.projects = data;
          }
        });
      }
      $scope.selectedNodes = [];
    };
    $scope.dragStart = function(event) {
      if (expanded) {
        return dragStartPosition = angular.element('#angular-tree').width();
      }
    };
    $scope.drag = function(e, width) {
      var x;
      if (expanded) {
        x = e.deltaX + dragStartPosition;
        if (x > $document.width() - 17) {
          x = $document.width() - 17;
        }
        if (x < 220) {
          x = 220;
        }
        angular.element(e.target).css({
          left: x + "px"
        });
        angular.element('#angular-tree').css({
          width: x + "px"
        });
        angular.element('#angular-content').css({
          left: (x + parseInt(width)) + "px"
        });
        return true;
      }
    };
    $scope.toggleTree = function(e) {
      angular.element(e.target).toggleClass("hide");
      angular.element(e.target).toggleClass("tie");
      angular.element('#angular-tree').toggleClass("hideable");
      angular.element('#angular-content').toggleClass("hideable");
      angular.element(e.target).toggleClass("hideable");
      expanded = !expanded;
      size = angular.element('#angular-tree').width();
      if (!expanded) {
        return $scope.hideTree();
      }
    };
    $scope.hideTree = function() {
      var a, b;
      if (!expanded && listenHidePanel) {
        a = 7;
        b = 10 + a;
        angular.element('#angular-tree').css({
          left: (-size - 7) + "px"
        });
        angular.element('#angular-content').css({
          left: (b - 7) + "px"
        });
        $timeout(function() {
          return listenHidePanel = false;
        }, 500);
      }
    };
    return $scope.showTree = function() {
      if (!expanded && !listenHidePanel) {
        angular.element('#angular-tree').css({
          left: 0 + "px"
        });
        angular.element('#angular-content').css({
          left: (size + 10 + 7) + "px"
        });
        $timeout(function() {
          return listenHidePanel = true;
        }, 500);
      }
    };
  }
]);

angular.module("ximdex.main.controller").filter("nodeSelected", function() {
  return function(input, arr) {
    var a, _i, _len;
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      a = arr[_i];
      if (((a.nodeFrom == null) && (a.nodeTo == null) && (input.nodeFrom == null) && (input.nodeTo == null) && a.nodeid === input.nodeid) | ((a.nodeFrom != null) && (a.nodeTo != null) && (input.nodeFrom != null) && (input.nodeTo != null) && a.nodeFrom === input.nodeFrom && a.nodeTo === input.nodeTo)) {
        return true;
      }
    }
    return false;
  };
});
